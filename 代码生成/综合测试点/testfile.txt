//09_BFS.sy

const int maxn = 1005;
const int maxm = 5005;
int to[maxm], next[maxm], head[maxn], cnt = 0;
int que[maxn], h, tail, inq[maxn];
void add_edge(int from, int To){
	to[cnt] = To;
	next[cnt] = head[from];
	head[from] = cnt;
	cnt = cnt + 1;
	to[cnt] = from;
	next[cnt] = head[To];
	head[To] = cnt;
	cnt = cnt + 1;
}
void init(){
	int i = 0;
	while (i < maxn){
		head[i] = -1;
		i = i + 1;
	}
}
void inqueue(int x){
	inq[x] = 1;
	tail = tail + 1;
	que[tail] = x;
}
int pop_queue(){
	h = h + 1;
	int res = que[h];
	return que[h];
}
int same(int s, int t){
	h = 0;
	tail = 0;
	inqueue(s);
	int res = 0;
	while (h < tail){
		int x = pop_queue();
		if (x == t) res = 1;
		int i = head[x];
		while (i != -1){
			if (!inq[to[i]]) inqueue(to[i]);
			i = next[i];
		}
	}
	int i = 0;
	while (i <= tail){
		inq[que[i]] = 0;
		i = i + 1;
	}
	return res;
}
int main(){
	int n = getint();
	int m = getint();
	init();
	while (m){
		int ch = getint();
		while (ch != 81 && ch != 85){
			ch = getint();
		}
		if (ch == 81){ // query
			int x = getint(), y = getint();
			printf("%d", same(x, y));
			printf("%d", 10);
		}else{ // union
			int x = getint(), y = getint();
			add_edge(x, y);
		}
		m = m - 1;
	}
	printf("%d", 0);
	return 0;
}