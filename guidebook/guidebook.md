# 编译技术实验指导书

## 一、绪论（王宇奇+陈茂）

### （一）编译器架构

主要介绍编译器的作用和架构

### （二）实验任务概述

主要介绍本学期实验各个部分完成的任务，以及考核，测评等说明

## 二、总体架构设计

## 二、词法分析

### （一）词法分析概述

#### 1. 编译器输入源程序

在介绍词法分析之前，我们先了解一下输入编译器的源程序实际上是什么形式。从人的角度看，源程序可以带有各种结构，如顺序结构、分支结构等等，而且我们还可以通过空格、换行等来把一个个单词清晰地分开。但是从编译器的角度看，源程序仅仅是一个**线性的字符串**。

例如对于下面这个简单的分支结构源程序：

```c
int main() {
	int var = 8+2;
	if (var != 10) {
		printf(“error!”);
	}
	else {
		printf(“correct!”);
	}
	return 0;
}
```

对于编译器而言，输入的是这样一个字符串：

```
int main() {\n\tint var = 8+2;\n\tif (var != 10) {\n\t\tprintf(“error!”);\n\t}\n\telse {\n\t\tprintf(“correct!”);\n\t}\n\treturn 0;\n}
```

这个字符串是由一个个字符组成的连续序列，不具有其他复杂结构。这样一个非结构化的线性字符串对于编译器后续的分析工作是十分不利的，因此，编译器的第一步就是要把这样一个线性字符串分割成一个个单词，便于后续分析。

#### 2. 词法分析器的作用

词法分析器作为编译器的第一部分，承担的任务就是**通过扫描输入的源程序字符串，将其分割成一个个单词，同时记录这些单词的类别信息**。而对于源程序中一些对编译没用的符号，如'\n'和注释等，词法分析器也会进行适当的处理（如忽视跳过，记录当前行号等）。

<img src="C:\Users\Charles\Desktop\学校文件\compiler course\guidebook\figure\lexer_1.png" alt="lexer_1" style="zoom:40%;" />

如图所示，经过词法分析器的解析，我们就可以从词法分析器依次获取每个单词的信息，包括单词值和单词类别，用于后续的编译。

需要注意的是，词法分析器只负责单词的划分解析，不涉及具体的语法和语义判断。

### （二）词法分析器实现思路

#### 1. 词法分析器工作过程

在了解了词法分析器的作用后，我们来进一步学习词法分析器的工作过程。

一般而言，词法分析器包含以下部分：

- 源程序字符串`source`：输入编译器的源程序字符串
- 位置指针`p`：指向**下一个待解析的单词的起始字符**，初始化时指向source的第一个字符
- 单词值`token`：解析的单词值，为字符串
- 单词类别`type`：解析的单词类别，枚举类型
- 行号`line`：当前解析位置在源程序中的行号
- 数值`number`：解析的单词如果为数字（该单词本身是一个字符串），则设置number为该单词表示的数值
- `next`：词法分析器对外提供的接口，用于进行一次解析

此外，也可以根据实际需要额外添加其他部分。下面我们来看词法分析器大致的工作过程（黄色部分为本次解析的部分，灰色部分为已经解析完成的部分）。



<img src="C:\Users\Charles\Desktop\学校文件\compiler course\guidebook\figure\lexer_2.png" alt="lexer_2" style="zoom:40%;" />

1. 初始化时，**`p`指向`source`的第一个字符**，`line=1`，其他部分为空。
2. 解析第一个单词"int"，并设置`token`和`type`为相应的单词值和单词类别，**`p`指向下一个待解析的单词的初始字符**。
3. **跳过空格字符**，解析第二个单词"main"，并设置`token`和`type`为相应的单词值和单词类别。
4. 经过若干步后，跳过"\\n\\t"并**`line`加1**，解析单词"int"，并设置`token`和`type`为相应的单词值和单词类别。
5. 经过若干步后，跳过空格字符，解析单词"10"，设置`token`和`type`为相应的单词值和单词类别，同时设置`number=10`。
6. 解析最后一个单词";"，设置`token`和`type`为相应的单词值和单词类别，解析结束。

编译器的其他部分通过每次调用`next`来解析一个单词，并通过`token, type, line, number`来获取本次解析得到的单词的相关信息。其中，最为重要的是每次调用`next`时，如何解析出一个单词（即图中的黄色部分）。下面介绍这一部分常用的方法——有限自动机。

#### 2. 有限状态自动机

有限状态自动机FSA是处理形式化语言的重要工具，常常用于识别特定模式的字符串。有限状态自动机FSA内部包含一个当前状态$q$和转移函数$δ$，对于一个输入的字符$a$，FSA将根据当前状态$q$和字符$a$转移到下一个状态$p$，即有$p=δ(q,a)$。

这里用一个简单的例子来说明FSA的工作流程。

<img src="C:\Users\Charles\Desktop\学校文件\compiler course\guidebook\figure\lexer_3.png" alt="lexer_3" style="zoom:40%;" />

上图是一个用于识别"hello"和"here"两个单词的FSA，初始时FSA处于起始状态$q_0$，后续每读入一个字符$a$，都将根据当前状态和$a$进行一次状态转移（即沿着图中的对应边进入下一个状态），在到达$q_5$或$q_7$后，FSA就成功识别了一个"hello"或"here"单词。需要注意的是，在读入"he"时，我们不能判断当前这个单词是"hello"还是"here"，需要根据读入的下一个字符进行判断并转移到不同的状态分支（对应图中的$q_2$）。此外，这个例子也没有考虑异常情况，如读入字符'z'。

那么，FSA和我们的词法分析器有什么关系呢？不难发现，词法分析的单词中，很多都具有特定的结构：保留字和许多运算符号具有固定的字符串值，如main，break，+，&&，这些固定的串值可以通过类似上面例子的FSA识别；标识符和常数具有规定的结构，如标识符由一个字母或下划线开始，后面跟若干个字母或数字或下划线（如_a1_2b3），而常数则由数字开始，后面跟若干个数字（如123），虽然它们没有固定的串值，但是也可以通过FSA来进行识别。例如，下图是一个识别标识符的FSA。

<img src="C:\Users\Charles\Desktop\学校文件\compiler course\guidebook\figure\lexer_4.png" alt="lexer_4" style="zoom:40%;" />

因此，我们完全可以对每种单词都构造一个小的FSA，最后再将它们合成一个大的FSA，帮助我们的词法分析器识别所有的单词。

但是，在实际实现的过程中，为每种单词都构造一个FSA并最终将它们合并，将会产生数量巨大的中间状态和状态转移，这是十分繁琐且没有必要的。这里给出一种简单的基于贪心策略的实现方法，这种方法通过”贪心“地读取一串字符来简化许多繁琐的状态转移。

1. 每次调用next时，词法分析器先跳过当前位置的所有空白符，如果有'\n'则行号加1. 如果当前位置有注释，则跳过。
2. 如果当前字符是字母或下划线，则继续往后读取一串由字母或下划线或数字组成的字符串，直到结束或遇到不是这三者的字符，然后对于刚刚读取的这个字符串，到保留字表中进行查询，如果这个字符串属于保留字，如int，则按对应的保留字处理，否则按标识符处理。
3. 如果当前字符是数字，则继续往后读取一串由数字组成的字符串，直到结束或遇到非数字字符，然后按常数来处理刚刚读取的这个字符串。
4. 对于剩下的符号，如+,(等，只需要进行一次简单的判断即可。

事实上，可以发现前面词法分析器工作过程的例子正是按照这种方式来解析单词的。

#### 3. 注意事项

注释对于后续的编译过程没有任何影响，因此应该在词法分析阶段就过滤掉。我们需要考虑的注释有两种，一种是单行注释，一种是多行注释。

```c
// 这是一个单行注释
/* 这是一个
	多行注释 */
```

对于单行注释而言，一旦识别到"//"，则后面的内容全部跳过，直到遇到换行符；对于多行注释而言，一旦识别到"/\*"，则到下一个"\*/"中间的内容都要跳过。这里需要特别注意如下几种情况：

```c
/* ***** 这是一个注释 ****123/ **** 
********* 4/2 */

/* 这也是一个//注释  */

// /* 这还是一个注释 */ 

int a = 2048 / /* 这依然是一个注释 */ 1024; // 注意不要把除号当成注释
```

此外，我们会发现单词中有一些单词存在前缀重叠的情况，如'<'和'<='，对于这些前缀重叠的单词，我们单单读入一个符号是无法判断的，因此需要”偷看“下一个字符来判断是哪一种单词。

#### 4. 词法错误

一个完整的编译器，除了能够编译出正确的目标代码，还需要能够对各种错误进行识别和检测。在词法分析阶段，我们可以完成部分词法错误的识别，当遇到下列错误时，你的编译器需要报错：

| 错误类型 | 错误类别码 | 解释                                                         | 对应文法                            |
| -------- | ---------- | ------------------------------------------------------------ | ----------------------------------- |
| 非法符号 | a          | 格式字符串中出现非法字符，报错行号为**\<FormatString\>**所在行数。 | \<FormatString\> → ‘“‘{\<Char\>}’”’ |

## 二、语法分析

### （一）语法分析概述

在上一节中，我们通过词法分析将输入的源程序解析成一个个单词。在语法分析部分，我们将对这些单词进行进一步地分析，将其建立成结构化的语法树，以便于后续的编译。

#### 1. 语法树

语法树是按照给定的文法，将一个句子转化为有结构层次的树结构。**树中的每个节点都代表一个语法成分，而其子节点则代表组成该语法成分的其他语法成分，根节点为开始符号**。以下面的几条文法为例，假设Exp为开始符号（可以理解成最高级的语法成分）：

```c
左值表达式 LVal → Ident {'[' Exp ']'}
数值 Number → IntConst
基本表达式 PrimaryExp → '(' Exp ')' | LVal | Number
一元表达式 UnaryExp → PrimaryExp | Ident '(' [FuncRParams] ')' | UnaryOp UnaryExp
单目运算符 UnaryOp → '+' | '−' | '!'
乘除模表达式 MulExp → UnaryExp | MulExp ('*' | '/' | '%') UnaryExp
加减表达式 AddExp → MulExp | AddExp ('+' | '−') MulExp
表达式 Exp → AddExp
```

那么对于下面这个简单的句子（其中a和b为Ident）

```c
a + (3 + b) * 2
```

我们则可以建立如下的语法树：

<img src="C:\Users\Charles\Desktop\学校文件\compiler course\guidebook\figure\parser_1.png" alt="parser_1" style="zoom:40%;" />

语法树展现了**从上到下的推理过程**，即我们是如何从一个语法成分推理出我们的句子（在上述例子中，从Exp推理出`a+(3+b)*2`），也就是语法树从根开始往下生长的过程；另一方面，语法树还展现了**从下到上的归约过程**，即我们是如何从一个句子不断地“合成”，最终合并成一个语法成分的（在上述例子中，从`a+(3+b)*2`最终合成Exp语法成分），也就是语法树从叶子结点向上不断合并的过程。

除此之外，不难发现，语法树中的叶子结点都是终结符（因为到终结符就无法继续拆分了），而且叶子结点从左到右刚好组成了我们输入的句子。

#### 2. 语法分析的作用

前面我们介绍了给定文法时，一个句子的语法树是什么样的，以及语法树的一些特点。那么，**为什么我们要将一个简单的句子转化成如此复杂的语法树呢？**原因就在于，一个简单的句子是线性结构，不包含相应的语法结构信息，如果直接对线性的句子进行处理，是非常困难的。而语法树的层次化结构可以很好地表现语法结构，以及语法成分之间的关系；而树结构又可以很方便地利用**递归**等方法来进行处理，因此，将输入的源程序转化成包含语法结构的语法树，将为后续的处理带来极大的便利。

例如，对于上面例子中的表达式

```c
a + (3 + b) * 2
```

对于人来说，可以很容易地确定表达式的运算顺序。但是，从计算机角度而言，要编写一个程序仅仅根据这个线性字符串来确定运算的顺序是比较困难的，尤其是当表达式更为复杂的时候。如果我们建立了语法树，则可以很轻松地利用递归等方法来进行计算。

<img src="C:\Users\Charles\Desktop\学校文件\compiler course\guidebook\figure\parser_2.png" alt="parser_2" style="zoom:40%;" />

例如，在上面的例子中，我们要求表达式Exp的值（图中序号1），那么我们只需要求出AddExp（序号2）和MulExp（序号3）的值并将它们相加即可。要求MulExp（序号3）的值，我们只需要求出MulExp（序号4）和UnaryExp（序号5）的值并将它们相乘即可。同样地，要求MulExp（序号4）的值，我们只需要求出AddExp（序号6）和MulExp（序号7）的值并将它们相乘即可。对于每种语法成分的处理，如AddExp和MulExp的计算求值，我们都可以采用递归的方法很方便地实现，而且**语法树的层次结构自然保证了计算顺序的正确性**。

事实上，就像上面介绍的表达式计算，后续的编译过程也是基于语法树，利用递归等方法来进行的。因此，**语法分析的作用就是根据词法分析器解析出来的一个个单词，生成这样一棵具有层次化结构的语法树**，方便后续的编译。

### （二）语法分析器实现思路

接下来介绍实现语法分析器（Parser）的常用方法——递归下降。

#### 1. 递归下降

由于树结构可以很方便的用递归来处理（例如DFS），因此，我们同样可以采用递归的方法来生成语法树。

递归下降的主要思路，就是**为每个语法成分都编写一个子程序，该子程序会调用其他的子程序来解析组成该语法成分的其他语法成分，每个子程序返回的结果都是一棵对应语法成分的子树**。具体来说，例如有以下文法：

```
A -> B '+' C
```

那么，就可以为语法成分A编写一个这样的子程序（可以暂时忽略词法分析器lexer的调用，只关注其他子程序的调用顺序）：

```
parseA() {
	B = parseB(); // 调用B的子程序，解析语法成分B
	if(lexer.type != PLUS) error();	
	lexer.next();	
	C = parseC();	// 调用C的子程序，解析语法成分C
	return new A(B,C);	// 返回由B和C组成的语法成分A
}
```

如下图所示，解析A的子程序分别调用解析B和C的子程序，得到了两棵蓝色的子树，再将两棵子树和终结符'+'合并为绿色的子树（即语法成分A的语法树）。而**在解析A的子程序中，我们并不关心解析B和C的子程序究竟做了什么，只关注其返回的结果。**

<img src="C:\Users\Charles\Desktop\学校文件\compiler course\guidebook\figure\parser_3.png" alt="parser_3" style="zoom:60%;" />

当然，解析A的子程序也可能被其他子程序调用，它们也不关心解析A的子程序究竟做了什么。而且解析A的子程序在调用其他子程序时，可能会再次调用解析A的子程序，例如以下文法：

```
A -> B '+' C
C -> A | '1'
```

那么，解析C的子程序就有可能调用解析A的子程序，这就是递归下降中的递归思想。

**总而言之，我们只需要为文法中的每个语法成分都编写一个子程序并确保它们之间的正确调用，最后调用开始符号的解析子程序，就可以生成整棵语法树。**

#### 2. 词法分析和语法分析的配合

前面我们强调了语法分析利用词法分析解析出的一个个单词来构建语法树，因此，在编写递归下降程序的过程中，需要特别注意语法分析和词法分析的配合。如果任何一个地方错误调用了词法分析，就可能对整个语法树的构建造成影响。

为了确保语法分析和词法分析的配合，我们做出如下规定供参考：

- 一个子程序在调用其他子程序前，需要调用词法分析器来预读一个单词
- 一个子程序在退出时，需要调用词法分析器来预读一个单词

有了上述规定，就可以确保：

- 刚进入一个子程序时，词法分析器已经预读好了一个单词
- 从一个子程序返回时，词法分析器已经预读好了一个单词

因此，对于前面例子中的解析A的子程序，词法分析器的调用顺序如下：

```
parseA() {
	// 进入子程序A时，词法分析器已经预读好一个单词，从而确保了进入子程序B时，词法分析器已经预读好一个单词
	B = parseB(); 
	// 从子程序B返回时，词法分析器已经预读好了一个单词（B后面的单词），这个单词应该是'+'，检查是否符合
	if(lexer.type != PLUS) error();	// 检查'+'
	// 进入子程序C前，预读一个单词
	lexer.next();
	C = parseC();
	// 从子程序C返回时，词法分析器已经预读好了一个单词（C后面的单词，也是A后面的单词）
	// 从而保证了子程序A退出时，词法分析器已经预读好了一个单词（A后面的单词）
	return new A(B,C);
}
```

这样我们就可以确保语法分析和词法分析的协调配合。

#### 3. 多产生式

如果一个语法成分只有一条产生式，那么其解析方法就是唯一确定的。但是文法中可能存在某个语法成分有多条产生式，例如

```c
语句 Stmt → LVal '=' Exp ';'
| [Exp] ';' 
| Block 
| 'if' '(' Cond ')' Stmt [ 'else' Stmt ] 
| 'while' '(' Cond ')' Stmt 
| 'break' ';' 
| 'continue' ';' 
| 'return' [Exp] ';' 
| LVal '=' 'getint''('')'';' 
| 'printf''('FormatString{','Exp}')'';'
```

那么，**在解析Stmt的子程序中，就要考虑选择哪一条产生式进行后续的解析。**这里，我们可以考虑产生式右边的FIRST集。

假设A是某一条产生式的右部。那么A的FIRST集是一个终结符的集合，它由A能推理出的所有句子的第一个终结符组成。具体来说，对于产生式

```c
Stmt -> 'if' '(' Cond ')' Stmt [ 'else' Stmt ] 
```

很明显，该产生式的右部所能推出的任何句子的第一个终结符一定是'if'，因此，其FIRST集中只包含一个终结符'if'。

对于产生式

```c
Stmt -> Block
Block → '{' { BlockItem } '}'
```

则该Stmt产生式的右部所能推出的任何句子的第一个终结符一定是'{'，其FIRST集只包含一个终结符'{'。

对于产生式

```c
Stmt -> Exp
Exp → AddExp // EXP的FIRST={(,Number,Ident,+,-,!}
AddExp → MulExp | AddExp ('+' | '−') MulExp // AddExp的FIRST={(,Number,Ident,+,-,!}
MulExp → UnaryExp | MulExp ('*' | '/' | '%') UnaryExp // MulExp的FIRST={(,Number,Ident,+,-,!}
UnaryExp → PrimaryExp | Ident '(' [FuncRParams] ')' | UnaryOp UnaryExp // UnaryExp的FIRST={(,Number,Ident,+,-,!} 其中，(,Number,Ident属于PrimaryExp的FIRST，因此也属于UnaryExp的FIRST
UnaryOp → '+' | '−' | '!'
PrimaryExp → '(' Exp ')' | LVal | Number // PrimaryExp的FIRST={(,Number,Ident}，其中Ident属于LVal的FIRST，因此也属于PrimaryExp的FIRST
LVal → Ident {'[' Exp ']'}  // LVal的FIRST={Ident}
```

按照**自底向上**的顺序，根据注释，我们可以求出该Stmt产生式右部Exp的FIRST集为$\{+,-,!,(,Ident,Number\}$（这里将Ident和Number视为终结符，因为它们是通过词法分析直接得到的单词）。

求出Stmt每条产生式的右部的FIRST集后，我们就可以根据这些FIRST集来编写解析Stmt的子程序。

```c
Stmt -> 'if' '(' Cond ')' Stmt [ 'else' Stmt ] 
```

例如，由于终结符'if'只在上面这条产生式的FIRST集中出现，因此，如果当前词法分析的单词为'if'，则只能利用这条产生式来进行解析。同样地，'while'和'break'等也是如此，据此，可以编写出下面部分的子程序：

```c
parseStmt() {
	if(lexer.type == IFTK) {
		// 用 Stmt -> 'if' '(' Cond ')' Stmt [ 'else' Stmt ] 解析
	}
	else if (lexer.type == WHILETK) {
		// 用 Stmt -> 'while' '(' Cond ')' Stmt 解析
	}
	......
}
```

需要特别注意Stmt的这几条产生式

```c
 Stmt → LVal '=' Exp ';'	// FIRST={Ident}
| LVal '=' 'getint''('')'';' 	// FIRST={Ident}
| [Exp] ';' 	// FIRST={(,Number,Ident,+,-,!}
```

其产生式右部的FIRST集存在交集$\{Ident\}$，因此，**如果当前词法分析的单词为Ident，我们就不能直接判断选择哪一条产生式进行解析。**

这里提供一种参考思路。考虑到Exp可以推理出LVal（Exp -> AddExp -> MulExp -> UnaryExp -> PrimaryExp -> LVal），因此我们**可以用Exp的解析方法来解析LVal**。如果当前单词为Ident，则

1. 首先利用调用Exp的子程序来解析出语法成分Exp，判断下一个单词是';'还是'='，如果是';'，则按第三条产生式处理，完成Stmt解析，否则转第2步，从前两条产生式中选择一条解析，.
2. 从Exp提取出LVal（该Exp一定由唯一的LVal组成），继续判断下一个单词是不是'getint'，如果是则按第二条产生式处理，否则按第一条产生式处理，完成Stmt解析

注意，如果采用Exp的解析方法来解析LVal，你需要确保输出的结果正确（即输出应该是按照LVal的解析方法来解析LVal）。

对于除Stmt以外的其他语法成分的多产生式，也需要仔细考虑产生式右部的FIRST集，以编写正确的解析子程序。

#### 4. 左递归文法

文法中存在左递归文法，如果直接据此编写递归下降子程序，将会导致无限递归，最终栈溢出程序崩溃。

```c
AddExp → MulExp | AddExp ('+' | '−') MulExp
MulExp → UnaryExp | MulExp ('*' | '/' | '%') UnaryExp
```

我们需要通过改写文法来解决左递归问题。一般来说，有两种改写方法：

1. 将左递归改为右递归。我们可以将上述两条文法改写为：

   ```
   AddExp → MulExp | MulExp ('+' | '−') AddExp
   MulExp → UnaryExp | UnaryExp ('*' | '/' | '%') MulExp
   ```

   以解析AddExp为例，先调用MulExp的解析子程序，然后判断后面的单词是否是'+'或'-'，如果是，再递归调用解析AddExp的子程序。

2. 改写为BNF范式。通过分析结构，不难发现AddExp本质上是由若干个MulExp组成，MulExp本质上是由若干个UnaryExp组成，因此可以将上述两条文法改写为

   ```c
   AddExp → MulExp {('+' | '−') MulExp}
   MulExp → UnaryExp {('*' | '/' | '%') UnaryExp}
   ```

   其中，{}表示其中的语法成分可以出现0到若干次。

   以解析AddExp为例，先调用MulExp的解析子程序，然后判断后面的单词是否是'+'或'-'，如果是，则再次调用MulExp的解析子程序，直至解析完MulExp后的单词不是'+'也不是'-'。

需要特别注意的是，尽管编写程序时按照改写后的文法编写，但是需要确保输出的解析次序和原来的文法一致。以第二种改写方法为例，可以在每次解析`('+' | '−') MulExp`之前，先将之前已经解析出的若干个MulExp合成一个AddExp，输出一次\<AddExp\>。

#### 5. 语法错误

在语法分析阶段，需要在检测词法错误的基础上，进一步检测语法错误，包括以下几种类型。

| 错误类型        | 错误类别码 | 解释                                           | 对应文法                                                     |
| --------------- | ---------- | ---------------------------------------------- | ------------------------------------------------------------ |
| 缺少分号        | i          | 报错行号为分号**前一个非终结符**所在行号。     | \<Stmt\>,\<ConstDecl\>及\<VarDecl\>中的';’                   |
| 缺少右小括号    | j          | 报错行号为右小括号**前一个非终结符**所在行号。 | 函数调用(\<UnaryExp\>)、函数定义(\<FuncDef\>)及\<Stmt\>中的')’ |
| 缺少右中括号’]’ | k          | 报错行号为右中括号**前一个非终结符**所在行号.  | 数组定义(\<ConstDef\>,\<VarDef\>,\<FuncFParam\>)和使用(\<LVal\>)中的']’ |



## 三、中间代码生成

### （一）四元式（高远 4.25已完成）

#### 1. 四元式介绍

#### 2. 赋值语句

#### 3. 条件语句

#### 4. 循环语句

#### 5. 函数定义

#### 6. 函数调用

#### 7. 读入和输出

#### 8. 符号表设计 

### （二）llvm（王子懿）

#### 1. 简单介绍（4.25已完成）

##### （1）LLVM是什么

简单介绍LLVM

##### （2）三端设计

简单介绍三端设计，LLVM IR / LLVM IR 转 MIPS整体流程设计，以及前中后三端任务

##### （3）工具介绍

介绍Clang，LLVM安装及使用

##### （4）LLVM IR示例

给出demo示例，详细介绍.ll文件结构，简单介绍三地址码以及llvm常用指令。

#### 2. 主函数与常量表达式（4.25已完成）

##### （1）主函数

main,return,getint,printf

##### （2）常量表达式

加减乘除模正负

##### （3）测试样例

#### 3. 全局变量与局部变量（5.2完成）

##### （1）全局变量

##### （2）局部变量与作用域

##### （3）符号表设计

##### （4）测试样例

#### 4. 函数的定义及调用（5.9完成）

##### （1）函数定义

函数定义，参数，函数内部主体

##### （2）函数调用

包括主函数调用和函数调用/自调用

##### （3）测试样例

#### 5. 条件语句与短路求值（5.9，5.16完成）

##### （1）条件语句

与或

##### （2）短路求值

##### （3）测试样例

#### 6. 条件判断与循环（5.16，5.21完成）

##### （1）条件判断

if/else (或者case/switch)

##### （2）循环

while (或者for)

#### 7. 数组与函数（5.21完成）

##### （1）数组

getelementptr

##### （2）数组修改

数组传参维度变化

##### （3）测试样例


- 4/25 第0，1章
- 5/2 第2章
- 5/9 第3、4章
- 5/16 第4、5章
- 5/21 第5、6章

## 四、目标代码生成

### （一）动态内存管理



### （二）Pcode代码

#### 1. Pcode概述

pcode源于Pascal编译器产生的基于栈式虚拟机的中间代码。尽管中间代码（如四元式等）通常与机器无关，但是由于pcode是基于栈式虚拟机的，因此在生成pcode时必须考虑栈式虚拟机的一些特性，以及运行时的内存管理等。我们首先简单介绍关于栈式虚拟机的一些基本知识。

##### （1）栈式虚拟机的工作过程

栈式虚拟机可以理解为一个解释执行程序（如python解释器），它能够执行输入的pcode代码并产生相应的结果。

和我们学过的MIPS架构不同，栈式虚拟机中没有众多寄存器用于保存运算结果或变量（如MIPS中的`$t`寄存器和`$s`寄存器等），只有5个基本的寄存器，而且这些寄存器有特殊用途，不能用来保存运算结果。这就意味着变量、中间结果等都必须保存在内存的数据区中。

此外，栈式虚拟机的最大特点，就在于其将内存的数据区视为一个栈，大量的运算都是针对栈顶的入栈、退栈、计算来完成的，内存的动态管理也是基于栈的。例如，对于下列代码

```
int a = 1;
printf("%d", (a+2)*3);
```

<img src="C:\Users\Charles\Desktop\学校文件\compiler course\guidebook\figure\stack.png" alt="./figure/stack.png" style="zoom: 67%;" />

栈式虚拟机的栈变化如上图所示（黄色为栈顶，蓝色为次栈顶）：

1. 为变量a分配内存空间，并初始化
2. 栈顶压入变量a的值（为1）
3. 栈顶压入常数2
4. 栈顶与次栈顶相加，弹出两个元素，并压入运算结果（为3）
5. 栈顶压入常数3
6. 栈顶与次栈顶相乘，弹出两个元素，并压入运算结果（为9）
7. 弹出栈顶，并输出其值（输出9）

可以看到，在栈式虚拟机中，变量都保存在内存中，运算的中间结果也保存在内存中，且操作都是基于栈结构进行的。

##### （2）栈式虚拟机的5个寄存器

栈式虚拟机中只有5个寄存器：PC、SP、MP、NP、EP。这里简单介绍每个寄存器的作用：

- PC：程序计数器，和MIPS中的PC相同，指向下一条将要执行的指令
- SP：栈指针，指向栈顶，便于入栈退栈
- MP：标志指针，指向当前活动记录基地址（活动记录后续会介绍）
- NP：堆指针，指向空闲堆空间起始位置
- EP：顶指针，指向当前程序模块在栈中的最高位置

其中，由于我们的文法不涉及内存的运行时分配（如`new()`），因此实现的栈式虚拟机不需要堆区，也不需要NP寄存器；且可以假定栈式虚拟机有无限大的内存空间，因此也不需要EP寄存器来防止栈溢出。所以，我们真正需要实现的只有PC、SP和MP三个寄存器。

#### 2. Pcode内存管理

##### （1）Pcode的活动记录

前面介绍了动态内存管理的相关知识。在实现Pcode的动态内存管理时，活动记录有些许不同，主要是display区分成静态链（SL）和动态链（DL），同时Pcode代码的执行和这两个部分有很大的关系。Pcode动态内存管理一个典型的活动记录AR结构如下图所示。

<img src="C:\Users\Charles\Desktop\学校文件\compiler course\guidebook\figure\AR.png" alt="./figure/stack.png" style="zoom: 67%;" />

在栈式虚拟机中，一个活动记录主要包含以下几种数据：

- 返回值，表示该过程执行结束的返回值，可以理解为函数返回值
- 返回地址，表示该过程执行结束后应该返回的指令地址，类似MIPS中`$ra`寄存器的作用
- 静态链Static Link（SL），指向外层活动记录的基地址，可以理解为当前block外层的block的AR基地址。其“静态”体现在可以根据程序源代码直接确定block之间的嵌套关系。
- 动态链Dynamic Link（DL），指向调用者的活动记录的基地址。其“动态”体现在编译时无法确定被谁调用，只有运行时才能确定。
- 参数区，调用过程（函数）时用于传递参数，类似MIPS中`$a`寄存器的作用
- 数据区，包括局部数据区和临时变量区。其中，局部数据区存储定义的局部变量，临时变量区存储运算的中间结果等。

接下来我们重点分析AR中的静态链和动态链的作用。

##### （2）静态链SL

静态链的值是外层活动记录的基地址，作用主要是进行不同作用域下的变量访问。

对于如下代码：

```c
int main() {				// block1
	int a = 10, b = 20;
	if(a < b) {				// block 2
		int a = 0;			// 覆盖block1中a的定义
		while (a < 10) {	// block 3
			b = b + 1;		// 引用的block1的b  -------------------------1
			a = a + 1;		// 引用的block2的a  -------------------------2
		}
	}
	printf("%d",b);
	return 0;
}
```

根据静态的程序，如注释所示，我们可以确定三个block之间的嵌套关系，以及每个变量定义的作用域。

如下图所示，在程序执行到block3时，内层中存在3个AR，对应三个block。图中只简单画出了AR的局部变量区和静态链SL，黑色加粗表示AR基地址。

<img src="C:\Users\Charles\Desktop\学校文件\compiler course\guidebook\figure\static_link.png" alt="./figure/stack.png" style="zoom: 67%;" />

在程序执行到block3中的1处时，此时需要引用变量b，但是变量b在当前AR（AR3）中并没有定义，因此通过SL3找到AR2，发现在AR2中也没有变量b的定义，再次通过SL2找到AR1，在AR1中发现了变量b的定义。事实上，从源程序中也可以发现，引用的确实是block1定义的变量b。在执行到2处时，引用变量a，类似上面的过程，在AR2中找到变量a的定义，说明引用的是此处的变量a。上述过程说明，我们只要沿着静态链找，找到的第一个定义点，就是对应的变量定义。

在这里，我们定义两个重要概念：**level和addr**。level表示活动记录的深度，例如处于AR3中时，变量a的level为1（通过一次静态链搜索即可在AR2中找到定义），变量b的level为2（通过2次静态链搜索在AR1中找到定义）。addr表示变量与其定义AR的基地址的相对偏移。有了这两个概念，我们就可以很方便地来跨活动记录访问变量。例如，当前处于AR3，要访问变量b，则变量b的level为2，通过2次静态链搜索，找到AR1的基地址，再加上变量b的addr（距离基地址的相对偏移），即可确定变量b的绝对地址，访问变量b。

因此，在编译生成代码时，我们对变量的访问只需要给出level和addr两个值即可。注意，**level、addr的值在编译时是可以通过符号表确定的**，其中level可以根据block的相互嵌套关系（或符号表的深度）确定，addr则可以根据该block内的变量大小和数量确定，这也是“静态”的一种体现。

在上面的例子中，我们似乎可以直接确定变量a和变量b的绝对地址，甚至不用通过level、addr和静态链来访问。但是，对于更复杂的情况，如递归调用（`fibo(n)`），编译时，我们无法确定当前是第几次调用，也就无法确定AR的基地址（因为每次调用都要分配一个AR），无法通过绝对地址来访问，但可以通过相对的level和addr来访问。这也是静态链的必要性所在。

##### （3）动态链DL

动态链的作用主要是在函数调用完成后，能够使标志指针MP回到调用前的状态（指向调用者的AR基地址）。因此，调用者在调用函数时，需要将当前MP的值填入函数AR的DL中，函数执行完毕后，将DL的值赋给MP。由于编译时无法预知调用者的AR基地址，因此DL的值在编译时无法确定，只能在程序运行过程中再填入。

最后，建议在实现的过程中，按前面提到的AR结构来实现，预留出返回值、返回地址、SL、DL等区域（即使有些时候不需要），确保AR结构统一。

#### 3. Pcode代码介绍

在了解完栈式虚拟机和基于活动记录的动态内存管理后，我们正式介绍pcode代码。pcode代码围绕栈式虚拟机的特点，其操作主要针对栈来进行。下面给出一些供参考的pcode代码，当然你也可以根据自己的需要来自行设计代码。

| 指令名称 | 指令格式        | 说明                                                         |
| -------- | --------------- | ------------------------------------------------------------ |
| LIT      | LIT imm         | 加载立即数imm到栈顶                                          |
| OPR      | OPR opcode      | 进行栈顶与次栈顶（或者单独栈顶）的运算，并将结果压入栈顶；opcode决定运算类型 |
| LOD      | LOD level, addr | 以栈顶元素为动态偏移，加载内存中`(level, addr)+动态偏移`处的变量值到栈顶 |
| STO      | STO level, addr | 以栈顶元素为动态偏移，把次栈顶的元素写入内存中`(level, addr)+动态偏移`处的变量 |
| CAL      | CAL label       | 函数调用（分配AR、设置SL、DL、参数等）                       |
| BLKS     | BLKS            | 开启新的block（分配新的AR，设置SL、DL等）                    |
| BLKE     | BLKE level      | 结束当前block（回收当前AR）                                  |
| JMP      | JMP label       | 无条件跳转到label                                            |
| JPC      | JPC label       | 栈顶为0时跳转到label，否则顺序执行                           |
| JPT      | JPT label       | 栈顶不为0时跳转到label，否则顺序执行                         |
| INT      | INT imm         | 栈顶寄存器加imm，用于控制栈顶指针的移动                      |
| RED      | RED             | 读入数字到栈顶                                               |
| WRT      | WRT             | 输出栈顶数字                                                 |
| WRTS     | WRTS str        | 输出字符串                                                   |
| LABLE    | label:          | 标识label，用于跳转                                          |
| RET      | RET             | 返回调用者并回收AR                                           |
| LEA      | LEA level, addr | 加载(level, addr)处变量的绝对地址到栈顶                      |

下面对生成上述代码中的一些注意事项进行讲解。

##### （一）内存访问：LOD与STO

前面我们提到，通过level和addr，即可对内存中的变量进行存取。但是为什么在LOD和STO指令中，我们还需要以栈顶值为动态偏移呢？考虑下面的例子

```c
int main() {
	int arr[4] = {1,2,3,4};
	int i;
    i = getint();
	i = i % 4;
	printf("%d",arr[i]);  // ----------------- 1
	return 0;
}
```

尽管我们知道变量arr的(level, addr)，但是由于变量i的值在编译时无法确定，因此需要在运行时将变量i的值加载到栈顶作为动态偏移，再和(level, addr)配合进行数组元素的访问。

其中，1处输出arr[i]的pcode代码示例如下

```
LIT 0
LOD 0, 8	// 加载i到栈顶 i在当前AR中定义，level=0，addr=8，动态偏移为0
LOD 0, 4	// 加载arr[i]到栈顶，arr的level=0， addr=4，动态偏移为栈顶的i
WRT		// 输出arr[i]
```

##### （二）Block与AR：BLKS和BLKE

在sysY文法中，进入一个block相当于进入一个新的过程，需要分配一个活动记录AR；而从一个block退出时，也需要回收其AR。

需要注意的是，对于AR的分配，编译的时候，只需要生成BLKS指令即可，不必填充AR中的SL、DL（编译时也无法确定）；栈式虚拟机在解释执行BLKS指令时，会分配AR并填充上述字段。

通常来说，对于每个block，block的开始通过BLKS（block start）指令分配AR，结束时通过BLKE（block end）指令回收AR。但是，还需要考虑下面几种特殊情况：

```c
int func(int a, int b) {  // 函数AR
	int x = a + b;
	if(x < 10) {
		int y = x * a;
		if(y < 10) {
			return y;	// ---------------------1
		}
	}
	return 0;
}
```

在如上的函数中，执行到1处时，分配了3个AR，在执行return返回调用者时，需要一次性回收这三个AR。

```c
int main() {
	int i = 10;
	while(i > 0) { // 循环AR
		int a;
		a = getint();
		if(a < 10) {
			int b = a + i;
			if(b > 10) {
                break; // -----------------1
            }
		}
		i = i - 1;
	}
    return 0;
}
```

在如上代码中，进入循环后，执行到1处break时，需要回收循环体的三个AR。（continue同理）

对于这两种情况，建议**在编译过程中记录函数定义block和循环block的深度**，在遇到return/break/continue时，通过block深度确定需要回收多少个AR，从而在return/break/continue之前生成多少条BLKE指令。

##### （三）传地址的数组存取

在函数中，可能涉及到传地址参数，并以此来进行数组的存取。例如下面例子：

```c
void func(int arr[], int i) {
	printf("%d",arr[i]);
}

int main() {
	int arr[4] = {1,2,3,4};
	func(arr,2);
	return 0;
}
```

对于这种情况，建议先读取形参的值作为绝对基地址（图a），然后由绝对基地址+偏移值得到绝对地址存储在栈顶，来进行绝对寻址（图c）。注意，在绝对地址寻址时，可以将LOD/STO指令中的level和addr设置为特殊值以示区分。

<img src="C:\Users\Charles\Desktop\学校文件\compiler course\guidebook\figure\abs_addr.png" alt="./figure/stack.png" style="zoom: 67%;" />

下面给出上面例子中`func()`一种供参考的pcode代码。

```
INT 1 // 为形参arr分配空间（参数的值已经由调用者设置好）
INT 1 // 为形参i分配空间（参数的值已经由调用者设置好）
LIT 0
LOD 0, 4 // 加载参数arr的值（level为0，addr为4，动态偏移栈顶为0）
LIT 0
LOD 0, 5 // 加载参数i的值（level为0，addr为5，动态偏移栈顶为0）
OPR 1 // 栈顶与次栈顶相加 得到绝对地址压入栈顶
LOD -1, 0 // 按栈顶绝对地址寻址 level设为-1 addr设为0 表示按栈顶存储的绝对地址寻址
WRT // 输出栈顶元素
RET
```

#### 4. Pcode执行程序

除了pcode代码生成，还需要完成一个栈式虚拟机来解释执行生成的pcode。该栈式虚拟机需要包括：代码区（用于存储pcode代码），数据区（栈），三个寄存器（PC、MP、SP）。大部分指令的解释执行只需要按其对栈的操作进行实现即可，这里主要介绍一下函数调用和返回的解释执行过程。

函数调用（CAL指令）的执行过程包括：

1. 准备好若干个参数，存储在栈顶。
2. 为函数分配AR，并设置返回地址，SL（为全局变量所在的AR的基地址），DL（为调用者AR基地址，存储在MP中），参数。其中，实参原本在调用者的栈顶，需要复制到函数AR的参数区，之后函数只需要通过INT指令来为形参分配空间即可（参数值已经在参数区中存好了）。建议函数AR的起始可以直接覆盖栈顶实参，从而代替参数从调用者AR退栈的操作。
3. 分配好AR后，将MP设置为新的AR的基地址，栈顶指针SP指向参数区起始位置。
4. 设置PC为函数入口指令地址。

其中，第1、2步和BLKS的解释执行过程较为类似。

函数返回（主要是RET指令、BLKE指令）的执行过程包括：

1. 如果有返回值，将返回值填入函数第一个AR的返回值区域。注意，return语句可能出现在函数体中的任一个block，但是返回值建议填入函数的第一个AR（也就是CAL指令分配的AR）。
2. 回收所有函数AR（可以通过若干BLKE指令来回收）。
3. 恢复PC（返回地址）、SP（函数第一个AR基地址-1，刚好指向调用者栈顶）、MP（动态链）。如果有返回值，则执行INT 1指令，使SP+1，此时返回值正好处于调用者栈顶。

以下面这个简单的例子为例来进行具体说明：

```
int add(int a, int b, int c) {
	int r = a + b + c;
	return r;
}

int main() {
	int r = add(1,2,3);
	printf("%d",r);
	return 0;
}
```

<img src="C:\Users\Charles\Desktop\学校文件\compiler course\guidebook\figure\call_ret.png" alt="./figure/stack.png" style="zoom: 67%;" />

- 图（a）：main中准备好三个参数，存储在栈顶，准备调用add()
- 图（b）：执行CAL指令，为函数分配AR，设置返回地址、SL、DL，同时把参数填入到参数区，更新PC、SP、MP寄存器。注意，分配的AR可以直接覆盖原本栈顶的参数。
- 图（c）：add()中计算完结果，把结果填入AR中的返回值，准备返回
- 图（d）：执行RET指令，回收CAL分配的AR，恢复PC、SP、MP寄存器。由于有返回值，sp+1，使得返回值6刚好在栈顶，便于后续操作。

### （三）MIPS（高远）

#### 1. MIPS概述

主要介绍MIPS架构，几个重要寄存器的作用等

#### 2. 内存寄存器管理

寄存器的简单分配

#### 3. MIPS代码生成

分模块，如运算，数组，函数调用来介绍每个部分的翻译思路

## 五、代码优化（王宇奇，申浩佳）

### （一）初识SSA（王宇奇 4.25已完成）

### （二）Mem2reg （王宇奇 4.25已完成）

#### 1. phi insertion

确定插入phi函数的基本块

#### 2. variable renaming

对一个变量多处的命名进行重命名

### （三）Function Inline(函数内联) （王宇奇 5.2完成）

### （四）DCE(死代码删除) （王宇奇 5.9完成）

### （五）GVN&GCM(全局值标号&全局代码移动) （王宇奇 5.16完成）

### （六）后端消除PHI（申浩佳）

### （七）寄存器分配（申浩佳）

#### 1. 指派式寄存器分配

#### 2. 图着色寄存器分配

后端活跃分析，构造，简化，合并，冻结，溢出，选择，重新开始

### （八）除法优化（申浩佳）

### （九）窥孔优化（申浩佳）

### （十）指令选择（申浩佳）

### （十一）基本块合并（申浩佳）



