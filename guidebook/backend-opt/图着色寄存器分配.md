# 图着色寄存器分配

在之前的阶段当中我们都假定了有无限个寄存器作为临时变量，而实际上，寄存器是十分珍贵的计算资源，有着最为迅速的读写速度。编译课程的目标架构mips只有32个通用寄存器，显然无法满足"无限"寄存器的要求，所以如何进行寄存器分配是编译优化当中一个重要的问题。但是已有的数学证明已经指出寄存器分配是一个NP完全问题，所以一个好的寄存器分配策略应该能在较短的时间给出近似最佳的结果。课程组以虎书为蓝本，介绍一种近似线性时间的寄存器分配策略。

##  构造(build)

本阶段的主要任务是通过数据流分析方法，计算在每条指令执行时同时活跃的临时变量，该集合的每一对临时变量两两形成一条边加入冲突图中，

## 简化（simplify）

进行启发式图着色，删除度数小于K（通用寄存器个数，mips中是32个）的节点，简化冲突图，产生更多图着色机会

## 合并（coalesce）

进行保守的合并，减少最终代码的move指令。这一步非常重要，决定了整个图着色算法的质量，同时和前面的消phi有关联。

## 冻结（freeze）

使一部分度数较低的结点冻结，即变为传送无关的节点，无法在下一阶段进行合并。然后重新开始简化和合并阶段

## 溢出（spill）

将高度数的节点压入栈中。

## 选择（select）

对虚拟寄存器指派颜色，即分配真实的寄存器。

## 重新开始(restart)

如果存在没有找到颜色的寄存器，那么重新开始寄存器分配，直到没有溢出和简化为止（通常只需要迭代一次）。