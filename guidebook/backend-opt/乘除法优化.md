# 乘除法优化

对于处理器来说，执行乘除法的代价要远大于执行其他指令，而执行除法的代价又远大于除法的代价，所以我们理想的情况是通过算术运算将除常数转化为乘法和移位指令，将乘常数转化为移位和其他指令。我们只针对mips架构提出一种可行的除法优化方案，更加详细的实现以及具体的数学原理可以参考**Division by Invariant Integers using Multiplication&**

##  乘法优化

乘法优化比较简单，一般只需要判端常数是否是2的整数次幂即可，例如`x * 1024` 可以优化为`x << 10`，另外由于我们给出的rank计算标准是乘法的代价为加法的5倍，那么`x * 3`实际上可以考虑优化为`x + x + x`。一些特殊的常数也可以考虑优化例如`x * 10 `可以考虑优化为`x << 3 + x + x`。

## 除法优化

除法优化的思路是将除法指令转化为乘法指令和移位指令，即如下公式：
$$
quotient = \frac{dividend}{divisor} = (dividend * multiplier) >> shift
$$
该公式先乘一个较大的常数，然后用右移*shift*位得到最终的答案，使用该式子计算除法的核心是如何得到*multiplier*，另外由于mips架构是32位的，还必须要考虑溢出的问题。mips在执行乘法的时候会将结果保存到hi和lo寄存器当中，在被除数乘*multiplier*之后，很容易就会超过32位，这个就会出现一部分答案在hi寄存器中，一部分答案在lo寄存器当中，所以我们需要使*multiplier*尽量大（超过$2^{32}$），能够使答案的部分在hi寄存器当中。所以最终的公式可以写为如下形式
$$
quotient = \lfloor \frac{n}{d}\rfloor = \lfloor\frac{m * n}{2^{N + l}} \rfloor
$$
其中N是机器码长度32，最终获得答案的公式为$SRL(MULUH(m,n), shift)$，$MULUH$表示乘法之后取HI寄存器。

### 选择Multipier和获得Shift

论文当中提出了一种*mutiplier*和*shift*的获得方法，具体证明可以同学们可以查阅论文

![image-20230522102044515](/Users/shliba/Desktop/编译助教工作/后端优化/BUAA-Compiler-Course-2023/guidebook/figure/image-20230522102044515.png)

不等式当中的N是机器码的长度，在mips当中为32，该式子的意思是需要找到一个*m*使得*m\*d*之后大于$2^{N + l}$并且小于$2 ^{N + l} + 2^l$这样在右移$l$位之后可以得到最终的答案。

