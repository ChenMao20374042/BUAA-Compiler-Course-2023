# 后端消PHI

**这部分内容需要你的中间代码是SSA形式的，如果没有使用SSA形式的中间代码可以自行忽略这部分的内容**

SSA形式的中间代码本身就携带了大量信息，可以方便的进行很多中端优化，但是在代码生成的时候PHI指令实际上是无法被常规的汇编指令表示的，所以在进行代码生成之前需要将SSA形式的代码转换为汇编指令集能够接受的代码。

首先介绍一下**关键边（critical edges）**的概念，关键边是从一个有多个后继的节点指向有多个前驱的节点的边。消PHI最简单的一个思路是在源基本块跳转之前将PHI指令拆成多条move指令，但是如果程序中存在关键边，以下面的llvm代码为例

```
...
BB1:
%1 = phi i32 [ %2, %BB2 ], [ %3, %BB3 ]
%2 = phi i32 [%1, %BB2], [%3, %BB3] 
br label %BB4
BB2:
....
br  i1 %4, label %BB4 label %BB1
BB3:
...
br  i1 %5, label %BB4 label %BB1
BB4:
%6 = add i32 %1, %1
...
```

显然从BB2到BB1之间存在一条关键边，假设直接在BB3的尾部添加move指令，那么跳转到BB4时，move指令也会被执行，这个时候%1变量的值会被改变，而BB4对%1有引用，可能会造成错误，所以如果要在跳转前将PHI变成多条move指令需要消除关键边，一种显然的做法是在BB3和BB1之间再增加一个基本块BB5，BB3跳转到BB5之后再对BB1需要的PHI指令添加move指令，再从BB5跳转到BB1，需要注意的是，由于一个基本块的PHI指令有并行性，例如从BB2跳转到BB1中，%2正确的赋值应该是原来%1的值，而不是跳转之后赋值给%1的原来%2的值，所以这里的move指令用PC(parallel copy)指令代替。下面给出《the SSA book》当中一种参考的算法

![image-20230516095242744](/Users/shliba/Desktop/编译助教工作/后端优化/BUAA-Compiler-Course-2023/guidebook/figure/image-20230516095242744.png)

这个时候所有的PHI指令都被PC指令替代，但是mips体系结构里并没有类似PC的指令，所以我们需要生成一个有并行效果的move序列。这里我们介绍一种图算法，将变量的值视作图的节点，每一条PC指令视作图的边，算法循环的从PC集合当中遍历，如果对于一个$b \gets a$指令，不存在$c \gets b$指令，那说明b变量的赋值不会影响到并行性，直接将`move b, a`加入move序列当中，并将$b \gets a$从PC集合中删除，如果存在$c \gets b$指令，则添加一个临时变量$a^{'}$，将`move a', a`加入move序列当中，用$b \gets a'$替换$b \gets a$指令，这样加入一个中间变量之后$b$的赋值就不会影响$c$的赋值。具体的算法如下：

![image-20230516102917495](/Users/shliba/Desktop/编译助教工作/后端优化/BUAA-Compiler-Course-2023/guidebook/figure/image-20230516102917495.png)

至此，我们已经完成了PHI指令的消除，需要注意的是，这是最简单的一种消PHI的方法，会产生大量move指令和基本块，如果不进行后续的优化甚至可能取得不如非SSA中间代码的性能，幸运的是，我们可以通过在寄存器阶段合并move指令、窥孔优化以及基本块合并等多种方法优化指令序列。《the SSA book》当中介绍了更加有效的消PHI方法，如果同学们有兴趣可以自行选择阅读。