---
title: 中端优化(1)-初识SSA
date: 2023-04-08 19:19:24
tags:
  - 编译
categories:
  - 编译
---

# 初识SSA

首先欢迎各位同学勇于突破自我，来到编译器优化的部分！本部分优化教程适用于以SSA形式语言作为中端的编译器，例如课程组推荐的中端语言llvm。我们将从了解什么是SSA开始，到构建SSA，再到后面以SSA为基础的各种优化。编译器优化的道路可能充满各种bug与未知的困难，但是在完成一个又一个优化的过程中，你一定会充满成就感！经过mem2reg，你的代码将被去除掉大部分alloca和load指令；经过DCE(Dead Code Elimination)，你的代码会减少很多废话文学；经过func_inline，大部分程序经过你的编译器可能只剩下了一个函数；经过GVN&GCM，你将灵活的重排指令，创造更多可优化的空间...... 不过，万丈高楼平地起，我们先从初识SSA入手，进入中端优化的世界。

## 省流

本章看完你会了解：

- SSA的基本概念
- 非SSA转化为SSA的基本方法
- $\phi$运算与它的一些性质

## 什么是SSA

SSA的全写，即Static Single-Assignment（静态**单赋值**）。乍一看很难懂，但翻译成人话就是**每个变量在程序中只被赋值一次**。如下列程序便不是SSA程序：

```c
x = 1;	//	语句1
y = 2;	//	语句2
x = y;	//	语句3
```

’=‘作为赋值操作，左边的变量会赋上右边的值。上述代码中的语句1为x赋值1，语句3为x赋值y，这段程序对x进行了两次赋值，即违反了SSA的定义。显然，我们删除语句1或语句3，就可以让这段程序成为一段SSA代码。

在一段正常的c代码中，可能会出现很多非SSA的现象，如：

```
x = 1;		//	语句1
y = x + 1;	//	语句2
x = 2;		//	语句3
z = x + 1;	//	语句4
```

上述的代码中x变量被赋值了两次（语句1和语句3），这会使得很多优化很难进行。如果我们只看语句2和语句4，我们很容易会认为y和z值是一样的，均为x + 1。但是由于x中途被重赋值了，导致这个想法是错误的。如果我们能把程序改写成SSA形式，如下：

```
x = 1;			//	语句1
y = x + 1;		//	语句2
x_2 = 2;		//	语句3
z = x_2 + 1;	//	语句4
```

这里我们用了一个新变量x_2来替代x的重赋值操作，同时将所有后续用到x的地方均换成了x_2。这样的话，我们就会明显的看出y和z的值大概率是不一样的，使得优化过程不会因此出错。

这样的一个小小的例子应该能让大家了解到SSA形式程序的好处，也展示了一个将非SSA程序转换成SSA程序的方法。同学们可能已经摩拳擦掌准备将程序转换成SSA形式了，但先别急，实际的情况可能比上面的程序复杂的多，如：

```
x = input()
if(x == 42)
	y = 1;
else
	y = x + 2;
print(y)
```

上面的伪代码描述了一个存在分支的情况。这样的程序能不能够被叫做SSA程序呢？答案是不能。因为显然，按照SSA的定义，y变量在程序中被赋值了两次（尽管这两条语句不可能都被执行）。

那么我们应该怎么将这种程序转化为SSA呢？如果我们仍采用上述的命名方法，产生y_2来替代第二次命名，那么最后的print(y)应该用y还是y_2呢？我们直观的一个想法就是，如果有一种运算能够智能的判断选择y还是y_2就好了。没错，因此我们需要引入新的运算方法，$\phi$运算。

## $\phi$运算

还是用上面的例子，我们画出上述程序执行的流程图（后续我们会将其叫做CFG图）：

![defa81c6e2e5269e0049dd320583179.png](https://s2.loli.net/2023/04/08/y6YSvFUjoqZu3sm.png)

该程序目前无法转为SSA的关键点就在于，print(y)的时候，我们无法预先知道y会取左右两边哪个值。由此我们定义$\phi$运算，如果我们是从左边的基本块来的，就用左边的值；如果我们是从右边的基本块来的，就用右边的值（好像废话）。我们将这种**根据来源基本块来决定给这个变量赋什么值**的操作定义为$\phi$运算。

添加$\phi$运算后的流程图如下：

![620011ec20f77a15f561b30d2548fd2.png](https://s2.loli.net/2023/04/08/8KGNg6dp2cYhHEq.png)

图中给左右基本块编号为A，B，$\phi$运算中的A : y1表示如果我们是A块来到这的，那么我们给y3赋值y1;同理B : y2则表示如果我们是B块来到这的，那么我们给y3赋值y2。在后面的大部分情况中，出于简洁，我会简化$\phi$函数的书写形式（去除掉基本块标号以及冒号，来源基本块和对应取值按从左到右的顺序）。还有一点需要注意，$\phi$运算要放在基本块的首部，也就是说SSA化后的基本块的语句应该是先有一批$\phi$语句，随后跟着一堆非$\phi$语句的格式。

由此我们便实现了含有分支数据流的SSA转化。事实上，我们针对SSA的大部分讨论将围绕这个看似很废话的$\phi$运算展开。

## 多条SSA

上个例子是最基本的$\phi$函数使用的例子，实际情况仍然要比上述复杂的多($\phi$在下面代码块中用phi替代了)：

```c
y_3 = phi(y_1, y_2)		//	语句1
y_5 = phi(y_3, y_4)		//	语句2
```

在上述代码中，上述语句2中的y_3应该取什么值（语句1运算前的值还是语句1运算后的值）？



答案是语句1运算前的值。一个直观的理解是每个$\phi$语句是独立且平等的，这里的顺序只是一种方便记录的形式。每条$\phi$语句都对应了一组数据流信息，而在进入这个基本块之前，这些数据流是不互相影响的，因此在一个基本块的$\phi$语句也应该保持这种独立性，同时执行，或者说是**并行执行**。

以上的抽象表达没有看懂也没有关系，~~因为本来就是我瞎想的一种直观理解~~，只要记住多条$\phi$语句逻辑上要并行执行。至于我们怎么用串行模拟实现这种并行性，是我们之后需要讨论的。

## 小结

至此，你已经了解了SSA的基本知识。在后续的指导中，我们将逐渐深入讲解构建SSA和有关SSA的相关优化。有兴趣的同学可以按照以上提出的概念，自己先尝试将程序转成SSA形式，当然，后续我们也将讲解构建SSA的算法——mem2reg。
