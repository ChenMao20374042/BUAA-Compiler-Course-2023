---
title: 中端优化(2)-Mem2reg
date: 2023-04-12 16:21:32
tags:
  - 编译
categories:
  - 编译
---

# Mem2reg

> 本部分教程参考*Static Single Assignment book*，将其关键内容整合成指导书，如有困惑推荐参考原书

这一章我们将介绍如何将一个非SSA的形式转化到含有phi函数的SSA形式。首先看下面的一个例子（仅作参考）：

```
//	源语言
int main() {
    int x, cond = 1;
    if (cond > 0){
        x = 1;
    }
    else{
        x = -1;
    }
    return x;
}
```

```
//	未经mem2reg的llvm
define i32 @main() {
    %1 = alloca i32
    %2 = alloca i32
    store i32 1, i32* %1
    %3 = load i32, i32* %1
    %4 = icmp sgt i32 %3, 0
    br i1 %4, label %5, label %8

5:
    store i32 1, i32* %2
    br label %6

6:
    %7 = load i32, i32* %2
    ret i32 %7

8:
    %9 = sub i32 0, 1
    store i32 %9, i32* %2
    br label %6
}
```

```
//	经过mem2reg的llvm
define i32 @main() {
    %1 = icmp sgt i32 1, 0
    br i1 %1, label %2, label %5

2:
    br label %3

3:
    %4 = phi i32 [ 1, %2 ], [ %6, %5 ]
    ret i32 %4

5:
    %6 = sub i32 0, 1
    br label %3
}
```

回忆上次的内容，我们在介绍SSA时提及的两个主要的方法，一个是改名，一个是引入phi函数。我们这里也将主要按照这样的方法对SSA形式进行构建。SSA构建的标准算法包含两个过程：$插入\phi$ 指令 和 变量重命名。

## 插入phi指令

在这一个步骤里，我们会把构建SSA所需要插入的phi指令都一口气先插到里面。当我们遇到不同基本块汇集（converge）到同一个基本块的时候，便需要将phi指令插入到基本块中。看下面的例子：

![3ddc02aaac8cc8222c938b2fae33b2f.png](https://s2.loli.net/2023/04/12/vNZbMFSluXUjTOn.png)

我们将这种展示程序流程的图叫做控制流程图（**C**ontrol **F**low **G**raph），简记为**CFG**。上图中，B, C基本块汇聚到D，这导致我们无法确定y此时的取值来自于B还是C，只好插入phi函数实现SSA。一个直观的想法就是所有这种汇聚的基本块中都需要插入phi函数。用更加专业的语言来定义一下汇聚这个概念：

- 假设基本块n1和基本块n2是CFG中两个独立的节点，n3为另一个基本块节点
- CFG中存在两条路径n1->n3，n2->n3
- 这两条路径有且仅有n3这一个交点
- 那么我们定义n3是n1和n2的**join node**

定义完join node的概念后，我们便可以粗略的理解为：若n3 = join node(n1, n2)，且n1,n2定义了同一个变量v，那么我们要在n3中插入一个针对变量v的phi指令。但实际情况可能复杂的多，可能存在n3与其他基本块又汇聚回n1之类的情况，因此单一的join node概念肯定是不够的，我们拓广一下，提出join sets:

- 设S为一个基本块集合
- 当n为S中至少两个基本块n1, n2的join node时，我们称n为S的join node（注意此时S是一个集合）
- 我们将S的所有join node汇总起来，称为**join set**，记作J(S)

到这里，我们提出了一些新的概念来辅助我们找到将phi函数插到哪里。大家可能已经被绕晕了，我用上面图中的例子再具体化一下：

-  $D = join\ node(B, C)$ 
- 令 $S_1 = \{B, C\}$ , 则 $D∈J(S_1)$ ，且 $J(S_1) = \{D\}$ 
- 令 $S_2 = \{r,A,B,C,D,E\}$，则 $J(S_2)=\{A,D,E\}$  



在上面的例子中，变量y在B,C中被定义(def)，然后我们发现 $J(\{B,C\})=\{D\}$ ,因此在D中要构建phi指令。那么抽象出来就是对于一个变量v，我们先找到它的定义块集合 $Def_v$ ，简记为 $D_v$ ，然后再计算 $J(D_v)$ ，得到的即为我们应该插入phi指令的基本块集合。注意到，phi指令本身，也是对变量v的定义，但由于 $J(D_v∪J(D_v))=J(D_v)$ ，所以我们最终需要插入phi指令的基本块集合**还是 $J(D_v)$** 。



似乎问题到这里已经解决了，我们只需要遍历每个变量，计算出 $J(D_v)$ ，然后插入phi指令就好了，但是实际上求 $J(D_v)$ 的过程非常复杂。计算机科学家结合了图论中的一些概念，将问题转化的更好求解。下面介绍一下相关概念：

- **支配**(dominate)：如果CFG中从起始节点到基本块y的所有路径都经过了基本块x，我们说**x支配y**
- **严格支配**(strict dominate)：显然每个基本块都支配它自己。如果x支配y，且x不等于y，那么**x严格支配y**
- **直接支配者**（immediate dominator, idom）：严格支配n，且不严格支配任何严格支配 n 的节点的节点(直观理解就是所有严格支配n的节点中离n最近的那一个)，我们称其为n的直接支配者

下面是一个CFG：

![174bbb3ede71e89f176ee26f3ed65a8.png](https://s2.loli.net/2023/04/15/iD2GuQbarylp7mL.png)

我们可以举一些例子阐述一下上述的概念：

- 1严格支配3：因为程序如果要运行到3号基本块，必须要经过1号基本块（支配），且1!= 3（严格支配）。
- 3不严格支配7：因为程序如果要运行到7号基本块，可以不经过3，可以从4->5->7的线路走
- 7的直接支配者是2：依照上述概念，有1，2严格支配7，但显然2更近。严谨地说，1虽然严格支配7，但1还严格支配2（7的严格支配者），因此不符合上述概念，不是7的直接支配者。

需要注意的是，**每个节点的直接支配者有且只有一个**（除去entry节点）。

**支配边界**（**D**ominance **F**rontier）：节点 n 的支配边界是 CFG 中刚好**不**被 n 支配到的节点集合. 形式化一点的定义是： $DF(n)=\{x∣n支配x的前驱节点，n不严格支配x\}$ .

我们还是举个例子辅助理解：CFG图中沿着节点4向下走，5是被4支配的（如果程序要进行到节点5一定经过4），而接着到7节点的时候，我们发现4不再支配7了。由此我们便说4的支配边界是7。

类似J操作，我们对集合也可以定义DF操作， $DF(S)=\bigcup_{s{\in}S}DF(s)$  。DF还可以进一步迭代，即 
$$
DF_1(S)=DF(S)\\
DF_{i+1}(S)=DF_{i}(S)\\
DF^{+}(S)=DF_{i->\infty}
$$
还记得我们想要求的 $J(Def)$ 嘛？事实上:
$$
DF^{+}(S)=J(S\ \cup\ entry)
$$
这里的entry是程序的入口基本块。在SSA原文默认的程序中，我们需要在entry基本块中定义所有使用的变量，因此在没有entry基本块的基本块集合中，会有可能出现变量未被定义的情况。而在我们课程组推荐的llvm架构中，没有这样纯定义变量的entry块，因此可以大致理解为 $DF^{+}(S)=J(S)$ 。

那么任务就很明确了，对于每个变量v，求出 $DF^{+}(Def_v)$ 就知道了需要插入phi函数的位置。 

首先，我们先计算出CFG图。

> 这个根据同学们自己的中端架构来实现，其实就是根据基本块跳转指令来记录每一个基本块的next和prev基本块们就可以

接下来，根据CFG图计算支配关系。

> 推荐的一个方法是迭代计算。按照"某基本块的dom <- 某基本块所有前驱的dom的交集加上自己本身" 的策略进行更新，直到该基本块的dom集合不发生变化

在得到基础的支配关系后，直接支配关系和严格支配关系可以直接按照定义计算出来。

> 按照定义即可

接下来，计算最重要的支配边界，这里给一个计算CFG中每个节点的支配边界的伪代码：

![c115e7df981fee90b09c5663dd3d46b.png](https://s2.loli.net/2023/04/15/qBXmd1Z2yi6CHVJ.png)

上个步骤我们计算出了 $DF(S)$ ，下面我们提供一个参考插入phi函数的伪代码，我们的迭代支配边界也将在这个过程被计算出来：

![1.png](https://s2.loli.net/2023/04/15/wvPf9pKkCDtAZy3.png)

> 上述伪代码的思路很直接。对于某个变量v，首先W即 $Def_v$ ，对于其中的每个X，找到X的支配边界，由于它的支配边界不由X支配，即有可能来自于其他基本块，因此要插入phi指令（即如果从X过去，变量v就用X中定义的值）

在程序中插入 phi 函数后，程序中地每个变量依然会有多个定义，但程序中的每个定义都可以确定地到达对它的使用，在程序的任意一个位置，一定能够唯一地找到一个已定义变量的定义点，不会出现“这个变量可能在这里定义，也可能在那里定义”的情况（这种情况变成了 phi 函数定义了该变量，kill 了原有的多个定义）。

## 变量重命名

 为了使程序变为 SSA 形式，我们还需要对变量进行重命名。在程序中插入 phi 函数使得每一个变量的存活区间（live-range）被切割成了几片，变量重命名要做的就是给每个单独的存活区间一个新的变量名。

在上文计算支配关系的时候，基本块之间的直接支配关系可以构成如下图的支配树（dom tree）:

![8698f7b924b52596cd6e6e788e3b9c5.png](https://s2.loli.net/2023/04/15/Bn3Gd2NefhYc6tO.png)

在支配树上进行 DFS，DFS 的过程中，计算并更新每个变量 v 当前的定义 v.reachingDef，并创建新的变量。算法如下：

![49b929358ce6112d43263fcba13d306.png](https://s2.loli.net/2023/04/25/JMbLPFAOfRSIgZ4.png)

![2dbfcab580855e47c6413e1720832de.png](https://s2.loli.net/2023/04/25/Hct4UkTvDELsnKp.png)



