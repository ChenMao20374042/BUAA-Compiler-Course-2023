# 中间代码生成

在完成词法分析、语法分析和错误处理后，需要通过语义分析，将源程序翻译为中间代码，然后便是通过分析中间代码，将其翻译为最终的目标代码。一个好的中间代码，可以简化编译器的实现，便于调试和代码的优化。课程组给出了三种中间代码的实现的渠道，分别是LLVM，PECODE和自己设计的中间代码。下面，主要就第三点，给出一些自己设计的中间代码（四元式）的参考格式，同学们完全可以基于自己的想法来自由发挥。只要设计的中间代码可以准确无误地表达源程序的逻辑，并且便于优化，就是好的中间代码。

## 四元式

此处我们介绍一种中间代码的形式：四元式。四元式是一种形如(op, arg1, arg2, result)的指令格式，其中op是运算符，arg1和arg2是操作数，result是运算结果。例如，赋值语句 x = y + z 可以表示为：

```
+, y， z, t1
=, t1,  ,x
```

其中，+ 表示加法操作，= 表示赋值操作，y 和 z 是加法操作的两个操作数，t1 是临时变量，用于存储加法的结果，x 是赋值操作的结果。这段四元式的意思，是先把y和z的数值加和，赋值给t1，然后再把t1赋值给x。需要注意的是，在生成中间代码之前，需要为每个变量分配一个临时变量。临时变量是在中间代码生成过程中创建的，用于存储中间结果。临时变量可以采用 t1、t2、t3 等命名方式。

对于实验要求的文法来说，下面简单分析一下在生成中间代码阶段的各类语句（可自行设计）：

### 主函数

主函数和block块都是编译器中生成中间代码的基本单元。

主函数是整个程序的入口，通常包含全局变量的定义、函数的声明和调用以及其他一些初始化操作。在主函数中，编译器需要生成全局变量的初始化代码、函数的调用代码和程序结束时的清理代码等。Block块是一个语句块，通常由一组语句组成，可以是一个函数体、一个循环体或者一个条件语句块等。在block块中，编译器需要生成相应的控制流程代码，如条件分支和循环控制等。

对于主函数和block数据块，均可使用begin和end来描述其作用范围，大致四元式框架可描述如下：

```
main_begin,_,_,_

block_begin,_,_,_
xxxxxxx
block_end,_,_,_

block_begin,_,_,_
xxxxxxx
block_end,_,_,_

main_end,_,_,_
```

对于每个主函数与block块，均需要维护一个对应的符号表。

### 赋值语句

生成赋值语句的过程比较简单。假设要生成赋值语句 x = y + z，可以遵循以下步骤：

- 为加法操作分配一个临时变量 t1。
- 生成加法四元式 + y z t1。
- 生成赋值四元式 = t1 x。

对于数组元素，我们也有相应的表示方法，例如 a = num[0] 可以用如下步骤表示：

```
[], num, 0, t1 
=, t1, , a
```

对于二维数组，可将二维数组展开，当作一维数组处理即可。

### 条件语句

条件语句需要将条件表达式翻译成中间代码。假设条件语句为 if (x > y) then z = x + y，可以遵循以下步骤：

- 为比较操作符 >的结果分配一个临时变量 t1。
- 生成比较四元式 > x y t1（x大于y给t1赋值为1，否则赋值为0）。
- 生成条件跳转四元式 jnz t1 L（t1不为0则跳转至L处，否则继续运行）。
- 生成无条件跳转四元式 jmp M（不运行下方语句块）。
- 生成标记 L。
- 生成赋值四元式 = x + y t2。
- 生成赋值四元式 = z t2。
- 生成标记 M。

如果由if语句中存在else和elif，处理方法与上述一致，具体请同学们自行思考。

### 循环语句

循环语句需要使用跳转指令和标记来实现循环控制。假设循环语句为 while (x < y) do x = x + 1，可以遵循以下步骤：

- 生成标记 L。
- 为比较操作符 < 分配一个临时变量 t1。
- 生成比较四元式 < x y t1。
- 生成条件跳转四元式 beq t1 0 M(t1为0则跳转至M处，否则继续运行)。
- 生成赋值四元式 + x  1 t2。
- 生成赋值四元式 = t2 x。
- 生成无条件跳转至L。
- 生成标记M。

### 函数定义

函数定义也是编译器中生成中间代码的基本单元之一。函数定义描述了一个函数的参数列表、返回类型和函数体。在函数定义中，编译器需要生成函数的入口代码、参数初始化代码、局部变量的声明和初始化、函数体中的控制流程代码和函数的返回值等。我们可以模仿block和主函数的处理方法进行函数定义，例如对于如下代码

```
int f(int a,int b){
	xxxx
    return xxx;
}
```

我们可以这么定义

```
func_begin,f,_,_
para_int,a,_,_
para_int,b,_,_
xxxxxxxx
ret xxxxxx
func_end,f,_,_
```

在上述示例中，`func_begin`是函数的入口标签，`ret`指令用于将计算结果作为返回值返回给调用者，`func_end`是函数的结束标签。函数体中的局部变量可以使用临时变量来实现。

此外，函数定义中还需要维护函数的符号表，包括参数和局部变量的声明。函数调用时需要将参数传递给被调用函数，并根据函数定义的参数和返回值类型生成相应的中间代码。

### 函数调用

+ 在函数调用之前，需要将函数参数压入栈中。对于每个参数，可以生成一条对应的四元式，将参数值存储到一个临时变量中，并将该临时变量的地址压入栈中。例如，对于调用函数f(x, y)，可以生成以下四元式：

  ```
  =, x, _, t1    // 将x的值存储到t1中
  parm, t1, _, _ // 将t1的地址压入栈中
  =, y, _, t2    // 将y的值存储到t2中
  parm, t2, _, _ // 将t2的地址压入栈中
  ```

+ 在所有参数都被压入栈之后，可以生成一个函数调用四元式，将控制权转移给被调用函数，例如，对于调用函数f(x, y)，可以生成以下四元式：

  ```
  call, f, _, _  // 调用函数f
  ```

+ 在函数调用结束之后，需要将函数的返回值从栈中取出，并将其存储到一个临时变量中，并需要清空参数栈。

当然，这里给出的代码示例只包含了一些比较基础的语法，并没有覆盖文法中可能含有的所有情况。对于更复杂的情况，还需要同学自行思考中间代码的设计方案。

以上给出的四元式设计和中间代码规范格式都仅仅是中间代码参考架构，同学在设计过程中可以结合自己的想法对中间代码格式进行调整。中间代码的设计将直接影响到目标代码生成，所以同学在设计中间代码时一定要考虑到“如何将中间代码翻译成目标代码”，最好能具体到一些细节，以减少目标代码生成阶段中对中间代码的重构。若目标代码为MIPS指令集等汇编语言，中间代码需要尽可能向着汇编语言贴近，有些甚至可能就直接用汇编语言代替。

### 读入和输出

`getint()`非常简单，如遇到`b=getint()`的输入，直接使用以下四元式即可表示：

```
getint,_,_b
```

对于`printf`，可以将需要输出的字符串通过%d分割成多个字符串，对于每个%d，生成print_int中间代码，对于每一个字符串，生成print_str中间代码。

例如，对于如下代码：

```
printf("%d hello",x);
```

我可以用如下四元式表示：

```
print_int,a[1],_,_
print_string,hello,_,_
```

### 符号表设计

在编译器中，符号表是一个重要的数据结构，用于存储程序中的变量、常量、函数等信息，为编译器的各个模块提供了必要的信息。在中间代码生成过程中，符号表的作用是维护程序中变量、函数等信息，并为中间代码生成器提供必要的信息。

符号表通常包含以下信息：

- 符号名称：变量、函数等的名称；
- 符号类型：变量的数据类型、函数的返回值类型等；
- 存储地址：变量在内存中的地址、函数入口地址等；
- 作用域：变量、函数等的作用域；
- 其他属性：变量、函数等的其他属性，如是否是常量、是否被定义过等。

在中间代码生成过程中，维护符号表的过程可以分为以下几个步骤：

1. 符号表的建立和初始化：在编译器的初始化阶段，需要建立符号表并初始化，为后续的代码生成过程做好准备。符号表可以用一个哈希表或二叉查找树等数据结构来实现，以实现快速的查找和插入操作。
2. 插入符号信息：在编译过程中，当遇到变量或函数等符号时，需要将其信息插入符号表中。如果符号已经存在，则需要给出错误信息。插入符号信息时，需要包含符号名称、符号类型、存储地址、作用域等信息。
3. 查找符号信息：在代码生成过程中，当需要访问符号信息时，需要在符号表中查找相应的符号信息。查找符号信息时，需要提供符号名称和作用域等信息。如果符号不存在，则需要给出错误信息。
4. 更新符号信息：在程序的执行过程中，符号信息可能会发生变化。例如，当变量被赋值时，需要更新符号表中相应变量的值。更新符号信息时，需要提供符号名称和作用域等信息，并更新相应的属性信息。
5. 符号表的销毁：在编译器执行结束时，需要销毁符号表。销毁符号表时，需要释放所有动态分配的内存，并将符号表指针置为空。

维护符号表是编译器中的重要工作之一，它为编译器的各个模块提供必要的信息，并为代码生成过程提供了必要的支持。通过正确地维护符号表，可以保证编译器生成的中间代码的正确性和有效性。

# MIPS代码生成

中间代码生成后，我们就来到了编译器设计的最后阶段了。目标代码生成通常以编译器此前生成的中间代码、符号表及其他相关信息作为输入，输出与源程序语义等价的目标程序代码。 代码生成模块需要面向某一个特定的目标体系结构生成目标代码，这种目标体系结构可以是 X86、MIPS、ARM等，因此我们可以把目标代码生成理解成是对中间代码的翻译。对于不同体系结构，中间代码翻译成目标代码的处理方式也不同。下面我们给出一个中间代码为四元式，目标代码为MIPS指令结构的指导方案。

## 生成全局数据段

在 MIPS 汇编语言中，全局数据段使用 .data 伪指令来定义。全局数据段的定义应该包括程序中所有全局变量的声明。在生成四元式时，对于每个全局变量，需要记录其标识符、类型、变量名和初始值（如果有的话）。

生成全局数据段的步骤如下：

+ 在汇编文件中使用 .data 伪指令来定义全局数据段。

+ 对于每个全局变量，生成对应的指令。指令的格式应该根据变量的类型和初始化情况来确定。例如，对于 int 类型的变量，可以使用 .word 伪指令来分配 4 字节的空间。对于printf中的字符串，可以使用.asciiz来分配空间。

例如对于以下代码：

```
int a=2,b[10]={1,2,3,4,5,6,7,8,9,10},c;
int main(){
	printf("ssss");
}
```

我们可以生成以下MIPS代码

```
a: .word 2
b: .word 10,9,8,7,6,5,4,3,2,1,
c: .word 0
str0: .asciiz "ssss"
```

这里需要注意的是，在MIPS代码生成过程中，我们直接使用.word来给变量赋值，对于数组元素，其值的顺序与下标顺序正好相反。对于未赋初值的变量，我们默认给其赋值为0。

通过生成全局数据段，我们可以在程序运行之前为所有的全局变量分配内存空间，并在必要时将它们初始化为指定的值。这样，在程序的执行过程中，全局变量的值就可以被保存在内存中，并随时被读取和修改。

## 生成全局代码段

全局代码段包括了所有的全局函数，以及全局变量的初始化代码。在 MIPS 汇编语言中，全局代码段使用 .text 伪指令来定义。在生成四元式时，需要将每个全局函数转化为 MIPS 汇编语言的形式，并生成相应的代码段。对于全局变量的初始化代码，可以将其转化为 MIPS 汇编语言中的常量池，以便在程序运行时进行初始化。

### 寄存器分配

在不考虑优化的情况下，完全可以将所有变量都存储在内存中，寄存器仅暂存变量的值， 操作结束后将结果写入内存中的相应位置。因此，对于不考虑优化的代码生成部分来说，我们至多只需使用4个寄存器便可完成，而将最后的计算结果存入内存之中，我们可以通过循环利用的方式使用这些寄存器，例如，对于以下代码：

```
int a=1,b=2;
int c=a+b;
```

我们可以将mips代码写成这样：

```
li $t1, 1    //a=1
sw $t1, 0($sp)

li $t2, 2     //b=2
sw $t2, -4($sp)

lw $t3, 0($sp)   //c=a+b
lw $t0, -4($sp)
addu $t1, $t3, $t0
sw $t1, -8($sp)
```

我们需要在代码生成的过程中维护一个符号表，对于a=1这段代码，我们先用一个临时寄存器记录值，然后将其存入到内存的相应部分，并在符号表中记录它的位置，b=2同理，当运行到c=a+b时，我们会去符号表中找到存放a和b值的位置，并将其取出至临时寄存器中，进行计算，在计算结束后获得c的值，并继续存到相应内存中。这边需要注意的是，如果c并不是第一次被定义，那么应该从符号表中找到c最初被定义的地方，并将值存到上述地点。这些临时寄存器的值没有必要被长久保存，因此在使用后可以立即释放。

在代码生成时，我们不考虑复杂的寄存器分配方法，大家只要学会最基本的寄存器使用即可，后续在优化部分我们会着重讲述寄存器的分配方法。

### 数组的处理

不同类型数组在存储空间中的分配方案分别为：

+ 如果数组是全局数组，那么它里面的各个值依次排列在全局数据区 
+ 如果数组是函数中定义的局部数组，则数组中的值依次排列在对应函数的活动记录中 
+ 如果数组是参数数组，那么活动记录中记录的是数组的基地址

需要注意的是，为数组分配存储空间时不特别区分一维数组与二维数组：它们的区别仅仅 在于访问数组元素时的偏移计算方法有差异。 我们将与数组相关的操作分为两种：数组存取，数组地址传递。

+ 数组存取：当从某个数组中获取值或者向某个数组中存储值时，首先判断这个数组是全局数 组还是局部数组，然后获得其相对于静态数据区（或者当前活动记录基地址）的偏移，与 $gp（或$fp）求和，获得数组基地址。然后根据访问数组的位置，求出相对于数组基地址 的偏移。最后用lw或者sw访存。
+ 数组地址传递：仅出现在函数调用时。 当调用某个函数时，如果这个函数需要一个数组作 为参数，则需要把某个全局数组或者局部数组或参数数组的地址传入。若需要传入一个非参 数数组的地址，那么可以在编译时确定数组相对于静态数据区或当前活动记录的偏移，从而 与$gp或$fp求和，获得数组地址并传入。如果是参数数组，那么从活动记录中获取到的数 组值已经是数组地址，直接传入即可。如果需要传入二维数组中的某个一维数组的地址，那 么还需要加上偏移（动态计算）。

例如，对于以下代码

```
int a[2]={1,2};
a[1]=3;
```

我们可以如此操作

```
li $t1, 1  //第一行
li $t2, 0
sll $t2, $t2, 2
subu $t3, $fp, 0
subu $t3, $t3, $t2
sw $t1, ($t3)

li $t0, 2
li $t1, 1
sll $t1, $t1, 2
subu $t2, $fp, 0
subu $t2, $t2, $t1
sw $t0, ($t2)

li $t3, 3   //第二行
li $t0, 1
sll $t0, $t0, 2
subu $t1, $fp, 0
subu $t1, $t1, $t0
sw $t3, ($t1)
```

在定义数组时，我们首先找到该值对应地址的偏移量（相对于fp指针位置），在该位置赋以相应的值，并在符号表中记录。在需要使用该数组对应下标的值时，仅需要从符号表中找到其相对于fp指针的偏移量，并从内存中读出即可。当然，不要忘记在最后将值重新存到内存的相应部分。

对于在函数内访问参数数组，一般按照以下步骤执行：

1. 参数传递：

   - 在调用函数之前，将函数的参数按照约定传递给被调用函数。
   - 参数可以通过寄存器或栈进行传递。在传递参数时，需要将参数值放入相应的寄存器或栈位置。

2. 访问参数数组：

   - 如果函数的参数是以数组的形式传递的，可以使用基址寻址的方式来访问参数数组。
   - 在函数的入口处，通过将基址寄存器设置为当前栈帧指针（$fp）的值，可以轻松访问参数数组。

   

对于包含参数数组的函数

```
f(arr,len)
```

我们可以如下执行：

```
move $fp, $sp

# 访问参数数组
addiu $t0, $fp, 8       # 假设arr是相对于栈帧指针的偏移量为8
lw $t1, 0($t0)          # 加载数组元素arr[0]的值到寄存器$t1
lw $t2, 4($t0)          # 加载数组元素arr[1]的值到寄存器$t2
```

在上述示例中，我们假设参数数组`arr`相对于栈帧指针fp的偏移量为8。使用`addiu`指令将基址寄存器t0设置为fp+8，然后使用`lw`指令从相应的偏移量处加载数组元素的值到寄存器$t1、$t2等等。

通过调整偏移量和使用不同的寄存器，可以访问参数数组的不同元素。在实际的编译器实现中，还需要考虑参数的类型和对齐等因素来正确生成访问参数数组的代码。

### 短路求值

对于 if 条件分支语句的 && 短路， 可作如下变换：

```
// 变换前
if (a && b) {
	xxx
} else {
	xxx
}
// 变换后
if (a) {
	if (b) {
		xxx
    } else {
		xxx
	}
} else {
	xxx
}
```

对于 if 条件分支语句的 || 短路，可作如下变换：

```
// 变换前
if (a || b) {
	xxx
} else {
	xxx
}
// 变换后
if (a) {
	xxx
} else {
	if (b) {
		xxx
	} else {
		xxx
	}
}
```

若有 && 和 || 嵌套，可以按照符号的优先级将其拆成多个判断语句来处理。解析时遵循以下几点：

+  对 LAndExp 中每个 RelExp 进行判断：若该RelExp为真，则往后判断下一个 RelExp；若 为假，则直接跳转到当前 LAndExp 的尾部
+ 对 LOrExp 中的每个 LAndExp 进行判断：若该LAndExp为真，则直接跳转进入到 if 语句 块内部；若为假，则往后判断下一个 LAndExp
+  若所有的 LOrExp 判断完毕后还没发生跳转，说明不满足判断条件，此时跳转到 if 语句块 尾部（或 else 语句块首部）

如下图所示代码

```
if (a || ( b && c ) || d) {
	xxxx
}
```

可以修改为：

```
if (!a) {
	goto IF_OR_1
}
goto IF_BEGIN

IF_OR_1:
if (!b) {
	goto IF_OR_2
}
if (!c) {
	goto IF_OR_2
}
goto IF_BEGIN

IF_OR_2:
if (!d) {
	goto IF_OR_3
}
goto IF_BEGIN

IF_OR_3:
goto IF_END

IF_BEGIN:
	xxxx
IF_END:
```

我们一般采用如此方法进行短路求值。

### 函数调用

在四元式生成Mips汇编代码时，函数调用部分需要考虑以下几个步骤：

1. 函数调用的参数传递 在调用函数之前，需要将函数的参数压入栈中，以便函数内部可以访问到这些参数。参数的压入顺序一般是从右到左，即先将最后一个参数压入栈底，最后将第一个参数压入栈顶。
2. 保存当前函数的现场 在调用函数之前，需要将当前函数的现场保存起来，以便在函数返回时可以恢复。保存现场的主要内容包括程序计数器PC、栈指针SP和寄存器。
3. 跳转到函数入口地址 调用函数时，需要将程序计数器设置为被调用函数的入口地址。
4. 函数返回时的处理 在被调用函数返回时，需要将返回值存储在合适的寄存器中，并将调用函数的现场恢复。

例如，对于最简单的函数调用，f(1)，我们使用如下代码mips进行执行：

```
sw $ra, 0($sp)
subu $sp, $sp, 4

# PUSH:push 1
li $t1, 1
sw $t1, 0($sp)

# CALL:call f
move $fp, $sp
jal f

addiu $sp, $sp, 4
move $fp, $sp
lw $ra, 0($sp)
move $t4, $v0
```

首先第一步，将存到ra寄存器中存的返回地址存入内存，防止其被覆盖，第二步，将参数存到合适的地方以便接下来使用，第三步，调用函数，第四步，结束函数调用，恢复现场（取出函数调用前保存下来的值）并取出相应的函数返回值。

一般来说，$ra和 $fp 这两 个寄存器是函数调用时必须保存的寄存器，需要压入栈中。而其他寄存器是否需要保存，并没有标准答案。保存的寄存器越多，会带来更高的安全性，但同时造成的时间开销也会越大。具体需要保存和恢复哪种类型的寄存器，保存寄存器的数目是否要受到限制，这些需要同学们兼顾正确性和效率自行设计。

